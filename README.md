# Git / Terminal 

본 저장소는 Git을 사용하여 버전 관리를 진행했으며, GUI(SourceTree)와 함께 터미널 기반 Git 명령어를 병행하여 사용하고 있습니다.

## 명령어
```bash
# 현재 경로 및 파일 확인
pwd
ls -a

# Git 상태 확인
git status

# 변경 사항 스테이징 및 커밋
git add .
git comit -m "Singly Linked List"

# 원격 저장소로 푸시
git push
```

# C언어 기반 Data Structure and Algorithm을 학습 및 구현


## 2026-02-02 Singly Linked List
C언어로 구현한 단일 연결 리스트 예제입니다.
노드 생성, 삽입, 탐색, 삭제 등 단일 연결 리스트의 기본 연산을 직접 구현했습니다.

## 2026-02-03 Doubly Linked List
C언어로 구현한 이중 연결 리스트 예제입니다.
각 노드는 이전 노드와 다음 노드를 모두 참조하여, 정방향/역방향 순회가 가능하도록 구현했습니다.

## 2026-02-04 Circular Doubly Linked List
C언어로 구현한 환형 연결 리스트 예제입니다.
테일은 헤드의 '이전 노드' 이고 헤드는 테일의 '다음 노드'가 되도록 구현했습니다.

### 정리 
#### 배열 vs 링크트 리스트
1. 삽입
배열은 연속된 메모리에 데이터를 저장하기 때문에 중간에 요소를 삽입할 경우, 삽입 위치 이후의 모든 요소를 한 칸씩 이동시켜야한다. 이로 인해 삽입 연산은 평균적으로 O(N)의 시간이 소요되며, 배열의 끝에 삽입하는 경우에만 O(1)에 가까운 성능을 보인다. 단, 배열의 용량이 초과되면 재할당과 전체 복사가 발생할 수 있다.

링크드 리스트는 각 노드가 포인터로 연결된 구조이므로, 삽입할 위치의 노드를 이미 알고 있다면 포인터 연결만 변경하여 O(1)에 삽입이 가능하다. 다만 삽입 위치를 찾기 위해 탐색이 필요한 경우에는 O(N)의 시간이 추가로 소요된다.

2. 삭제
배열에서 요소를 삭제하면 삭제된 이후의 모든 요소를 앞으로 이동시켜야 하므로 삭제 연산의 시간 복수잡도는 O(N)이 된다. 배열의 마지막 요소를 삭제하는 경우에는 단순히 크기만 감소시킴녀 되므로 O(1)에 수행할 수 있다.

링크드 리스트는 삭제할 노드를 이미 알고 있다면 포인터 재연결만으로 노드를 제거할 수 있어 O(1)에 삭제가 가능하다. 하지만 삭제 대상 노드를 찾기 위해 리스트를 순회해야 하는 경우에는 탐색 비용으로 인해 O(N)의 시간이 필요하다.

3. 탐색
배열은 인덱스를 통해 임의의 위치에 즉시 접근할 수 있으므로 특정 요소에 대한 접근이 O(1)에 가능하다. 또한 정렬된 배열의 경우 이진 탐색을 적용하여 O(long N)의 탐색 성능을 얻을 수 있다.

링크드 리스트는 인덱스 기반 접근이 불가능하여, 특정 요소나 위치에 접근하기 위해서는 첫 노드부터 순차적으로 탐색해야 한다. 이로 인해 탐색 연산의 시간 복잡도는 항상 O(N)이 된다.

### 설계 개선 포인트
일반적으로 링크드 리스트 구현에서는 테일 노드의 위치나 노드 개수를 알아내기 위해 리스트 전체를 순회해야 하며, 이로 인해 O(N)의 비용이 발생한다. 이러한 방식은 반복적으로 호출될 경우 심각한 성능 저하를 유발 할 수 있다.

이를 개선하기 위해 리그트를 단순히 노드들의 집합으로 다루는 것이 아니라, 리스트 자체가 상태 정보를 관리하도록 구조를 확장할 수 있다.

```c
typedef struct tagNode
{
int data;
struct Node* next;
struct Node* prev
}Node;

typedef struct LinkedList
{
Node* head;
Node* tail;
int size;
}LinkedList;
```

헤드와 테일의 주소값과 리스트의 사이즈를 가지고 있는 구조체를 추가하여, 별도로 관리하도록 하여 테일 노드 접근과 노드 개수 조회를 순회 없이 수행할 수 있다.

## 2026-02-05 Stack (Array & Linked List)

C언어로 구현한 스택 자료구조 예제입니다.  
배열 기반 스택과 연결 리스트 기반 스택을 각각 구현하여 구현 방식에 따른 구조적 차이와 메모리 관리 방식을 비교할 수 있도록 구성했습니다.

### Array Stack
연속된 메모리 공간을 사용하는 배열 기반 스택입니다.  
`Top` 인덱스를 기준으로 Push / Pop 연산을 O(1) 시간 복잡도로 수행하며, 생성 시 스택의 최대 크기가 고정되는 구조입니다.

배열 기반 스택의 빠른 접근성과 고정 크기라는 한계를 학습하는 목적의 구현입니다.

### Linked List Stack
단방향 연결 리스트를 이용해 구현한 스택입니다.  
`Top` 노드를 기준으로 Push / Pop 연산을 O(1)로 처리하며, 동적 메모리 할당을 사용해 스택 크기에 제한이 없습니다.

노드 단위의 메모리 생성과 해제를 직접 관리하도록 구현하여, 배열 기반 스택과의 구조적·메모리적 차이를 비교하는 데 목적이 있습니다.

## 2026-02-06 Expression Calculator
C언어로 구현한 수식 계산기 예제입니다.  
중위 표기식(Infix Expression)을 후위 표기식(Postfix Expression)으로 변환한 뒤, 스택 자료구조를 이용해 계산을 수행하도록 구현했습니다.

## 2026-02-07 Array Stack (Resizable)
배열 기반 스택의 한계를 보완하기 위해 동적 확장(+30%) / 축소(-30%) 로직을 추가했습니다.
Push / Pop 과정에서 realloc을 사용해 실제 사용량에 맞게 용량을 조절하도록 구현했습니다.

## 2026-02-09 CircularQueue
C언어로 구현한 원형 큐(Circular Queue) 예제입니다.
배열 기반 큐에서 발생하는 공간 낭비 문제를 해결하기 위해 원형 인덱스 구조를 적용했으며, 
front와 rear 포인터를 모듈로 연산으로 순환시키는 방식으로 enqueue / dequeue 연산을 O(1)에 처리하도록 구현했습니다.